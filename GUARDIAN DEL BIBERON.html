<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUARDIAN DEL BIBERON!!!</title>
    
<script src="https://cdn.tailwindcss.com"></script>
    
<script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-theme': '#F59E0B', // Un naranja temático
                        'secondary-theme': '#FECACA', // Un color suave para texto
                        'game-bg-dark': '#1F2937', // Fondo oscuro para la Caja 3
                        'text-theme': '#FDE047', // Amarillo brillante para textos importantes
                        'danger-theme': '#EF4444', // Rojo para peligro/daño
                        'success-theme': '#10B981', // Verde para puntos
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        display: ['Bangers', 'cursive'], 
                    },
                }
            }
        }
    </script>
    
<link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
    <style>
        /* Estilo general para la aplicación */
        .app-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* Estilo para el fondo que se repite en Cajas 1, 2 y 4 */
        .repeat-bg {
            background-image: url('https://i.postimg.cc/YSgyQ8wF/Gemini-Generated-Image-v18httv18httv18h.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Estilo para el fondo de la Caja 2 */
        .caja2-bg {
            background-image: url('https://i.postimg.cc/kX5787QW/Gemini-Generated-Image-a9lsdma9lsdma9ls.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* NUEVO: Estilo para el fondo de la Caja 3 (JUEGO) */
        .caja3-bg {
             background-image: url('https://i.postimg.cc/2jL6yQDd/Gemini-Generated-Image-rb042brb042brb04.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Estilo para el Título Arco */
        .title-arc {
            font-family: 'Bangers', cursive;
            font-size: 3.5rem;
            text-shadow: 4px 4px 0 #FCD34D, 6px 6px 0 #EA580C;
            color: white;
            line-height: 1;
            transform: skewY(-2deg) rotate(-1deg);
        }

        /* Estilo para la Caja 3 (Juego) - Ocupa toda la pantalla */
        #game-canvas {
            display: block;
            background-color: transparent; /* El fondo lo da el div padre */
            touch-action: none; 
            cursor: pointer;
        }

        /* Overlay para Onomatopeyas (contenedor de posición) */
        #onomatopeya-overlay {
            position: absolute;
            /* CLAVE: Mover el overlay más arriba para despejar el centro */
            top: 25%; 
            left: 0;
            right: 0; /* Asegurar que ocupe todo el ancho para centrar el texto */
            pointer-events: none; /* No bloquear clicks en el canvas */
            z-index: 20;
            display: flex; /* Usar flexbox para centrar el texto dentro del overlay */
            justify-content: center;
            align-items: center;
            height: auto; /* Ajustar altura automáticamente al contenido */
        }

        /* CLAVE: Estilo para el texto de onomatopeya (controlado por JS) */
        #onomatopeya-text {
            font-family: 'Bangers', cursive;
            user-select: none;
            pointer-events: none;
            opacity: 0; /* Inicialmente oculto, controlado por JS */
            transition: opacity 0.1s ease-out; /* Transición para un efecto suave */
            text-align: center; /* Asegurar que el texto esté centrado horizontalmente */
            line-height: 1; /* Eliminar espacio extra entre líneas */
        }
        

        /* ESTILOS CRÍTICOS PARA EL EFECTO DE DAÑO (IMAGEN EPA) - TAMAÑO MAXIMIZADO Y DURACIÓN EXTENDIDA */
        #hit-image {
            /* Posicionamiento y tamaño base */
            position: absolute;
            top: 50%; /* Centro vertical */
            left: 0;  /* Pegado al borde izquierdo */
            z-index: 40; /* Capa alta - Asegura que esté DELANTE de todo */
            
            /* AUMENTO DE TAMAÑO DRAMÁTICO PARA ASEGURAR VISIBILIDAD */
            width: 60vw; /* 60% del ancho del viewport */
            height: 60vh; /* 60% del alto del viewport */
            object-fit: contain; /* Asegura que la imagen mantenga su proporción sin distorsionarse */

            pointer-events: none;
            
            /* 1. Definir la transición: solo 150ms para un efecto rápido */
            transition: transform 0.15s ease-out, opacity 0.15s ease-out;
            
            /* 2. Estado Inicial (Oculto): Centrar verticalmente, mover fuera del viewport y rotar */
            transform: translateY(-50%) translateX(-100%) rotate(-10deg); 
            opacity: 0;
        }

        /* 3. Estado Visible: Mover la imagen al borde (X=0) y rotación a 0 para un efecto de entrada */
        .hit-visible {
            transform: translateY(-50%) translateX(0%) rotate(0deg); /* Mover al borde, mantener centrado vertical, sin rotación */
            opacity: 1;
        }
        
        /* ================================================================
        ESTILOS PARA LA CAJA 4 (PUNTUACIÓN)
        ================================================================
        */
        .score-container {
            /* Contenedor principal sin fondo sólido */
            background-color: transparent; 
            /* Borde temático "roto" */
            border: 5px dashed #EF4444; /* Rojo peligro */
            box-shadow: none; /* Sin sombra de caja formal */
            transform: rotate(-3deg); /* Leve inclinación para un toque informal */
            padding: 1.5rem;
        }

        .score-card {
            /* Contenedor de datos con fondo semi-transparente */
            background-color: rgba(255, 255, 255, 0.2); /* Blanco 20% de opacidad */
            backdrop-filter: blur(5px); /* Pequeño desenfoque para que el texto resalte */
            border-radius: 0.75rem;
            padding: 1rem;
        }

        .score-title {
            /* Título grande y temático */
            font-family: 'Bangers', cursive;
            font-size: 2.5rem;
            text-shadow: 3px 3px 0 #000000, 5px 5px 0 #F59E0B;
            color: #EF4444; /* Rojo de Daño */
            line-height: 1;
            margin-bottom: 1rem;
        }

        .score-phrase {
            /* Frase final destacada */
            font-family: 'Bangers', cursive;
            font-size: 1.5rem;
            text-shadow: 2px 2px 0 #FFFFFF;
            color: #1F2937; /* Gris oscuro */
            background-color: #FDE047; /* Amarillo brillante */
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 2rem;
            transform: rotate(2deg); /* Inclinación opuesta */
        }
        
    </style>
</head>
<body class="bg-gray-900">

    
<div id="app" class="app-container repeat-bg">

        
<!-- CAJA 1: MENU PRINCIPAL (AJUSTE DE MARGEN Y MAX-WIDTH PARA PC) -->
<div id="caja-1" class="absolute inset-0 flex flex-col items-center justify-center p-4 lg:p-24">
            
<h1 class="title-arc text-center mt-16 lg:mt-0 mb-4 lg:mb-12">GUARDIAN DEL BIBERON!!!</h1>
            <h2 class="text-xl md:text-2xl font-sans text-white text-shadow-lg p-2 rounded-lg bg-black bg-opacity-40 mb-12 lg:mb-24 border-b-4 border-primary-theme max-w-lg lg:max-w-xl text-center">
                No te regales BICHITO de LUZ!!
            </h2>

            
<button id="start-game-btn" class="image-button">
                <img src="https://i.postimg.cc/j24007Qt/Biberon-Plus.png" alt="Empezar Juego" class="w-32 h-32 md:w-48 md:h-48 lg:w-64 lg:h-64 rounded-full shadow-2xl transition duration-300 transform hover:scale-110">
            </button>
        </div>

        
<!-- CAJA 2: SELECCIÓN DE PERSONAJES (AJUSTE DE MAX-WIDTH Y ESPACIADO PARA PC) -->
<div id="caja-2" class="absolute inset-0 flex flex-col items-center justify-start p-4 lg:p-12 hidden caja2-bg">
            
<h1 class="text-3xl md:text-5xl font-display text-text-theme mt-8 lg:mt-16 mb-6 lg:mb-12 p-2 rounded-lg bg-black bg-opacity-70 shadow-2xl border-b-4 border-danger-theme">ELIGE TU GUARDIAN</h1>

            <div id="character-grid" class="flex flex-wrap justify-center gap-6 md:gap-8 lg:gap-12 w-full max-w-2xl lg:max-w-4xl p-4 md:p-8 bg-black bg-opacity-40 rounded-xl shadow-2xl overflow-y-auto">
                
</div>

            
<div class="mt-auto mb-8 lg:mb-16">
                <button id="select-character-btn" class="image-button opacity-50 cursor-not-allowed">
                    <img src="https://i.postimg.cc/KzZ8HBM5/Boton-a-comerla.png" alt="¡A COMEEERLAA!!!" class="w-40 h-auto md:w-56 lg:w-64 transition duration-300 transform rounded-xl shadow-lg">
                </button>
            </div>
        </div>

        
<!-- CAJA 3: JUEGO (CANVAS) -->
<div id="caja-3" class="absolute inset-0 flex flex-col items-center justify-center hidden caja3-bg overflow-hidden">
            
            
<canvas id="game-canvas" class="w-full h-full"></canvas>

            
<div id="onomatopeya-overlay" class="absolute flex items-center justify-center inset-0 z-20 pointer-events-none">
                <div id="onomatopeya-text" class="text-4xl md:text-7xl"></div>
            </div>

            
<img id="hit-image" 
                 src="https://i.postimg.cc/R0YDCP2t/EPA.png" 
                 alt="Efecto de Colisión (¡Daño!)"
                 class="z-50 object-cover"
            >

        </div>

        
<!-- CAJA 4: PUNTUACIÓN (AJUSTE DE MAX-WIDTH PARA PC) -->
<div id="caja-4" class="absolute inset-0 flex flex-col items-center justify-center p-4 lg:p-12 repeat-bg hidden">
            
<div class="max-w-md lg:max-w-xl w-full score-container">
                <h1 class="score-title text-center">PEDIDO DE EXPLICACIÓN</h1>

                <p id="final-phrase" class="score-phrase text-center"></p>

                
<div class="text-left space-y-3 mb-8 text-xl font-sans score-card">
                    <p class="text-white text-shadow-lg">Puntos Normales: <span id="score-normal-final" class="float-right font-extrabold text-success-theme text-2xl">0</span></p>
                    <p class="text-white text-shadow-lg">Puntos Bonus: <span id="score-bonus-final" class="float-right font-extrabold text-primary-theme text-2xl">0</span></p>
                    <hr class="border-t-4 border-danger-theme my-2 opacity-50">
                    <p class="text-3xl font-extrabold text-white text-shadow-lg pt-2">SCORE TOTAL: <span id="score-total-final" class="float-right text-danger-theme text-4xl">0</span></p>
                </div>

                
<div class="mb-8 p-4 bg-gray-900/40 rounded-lg backdrop-blur-sm transform rotate(1deg)">
                    <label for="firma-input" class="block text-xl font-display text-text-theme mb-2">Lugar de firma (¡Ponete las pilas!):</label>
                    <input type="text" id="firma-input" placeholder="Escribe tu nombre..." class="w-full p-3 border-2 border-primary-theme rounded-lg focus:outline-none focus:ring-2 focus:ring-danger-theme shadow-inner text-gray-800 text-lg" maxlength="30">
                </div>

                
<button id="firma-btn" class="w-full py-3 bg-danger-theme text-white font-bold text-2xl font-display rounded-xl shadow-lg transition duration-150 hover:bg-red-700 transform hover:scale-105 active:scale-95 border-b-8 border-black">
                    FIRMA DEL RESPONSABLE
                </button>
            </div>
        </div>

    </div>

    <script>
        // ==================================================================================================
        // VARIABLES GLOBALES Y CONFIGURACIÓN INICIAL
        // ==================================================================================================

        const SCENES = {
            MENU: 'caja-1',
            CHAR_SELECT: 'caja-2',
            GAME: 'caja-3',
            SCORE: 'caja-4'
        };
        let currentScene = SCENES.MENU;
        
        // Estado del Juego
        let gameState = {
            currentScore: 0,
            bonusScore: 0,
            lives: 3,
            selectedCharacter: null,
            comboCount: 0,
            isEventActive: false,
            eventTimer: 0,
            eventPoints: 0, 
            eventComboMultiplier: 0,
            // NUEVOS ESTADOS PARA EL FEEDBACK DE DAÑO
            isHit: false, // Bandera si el jugador acaba de ser golpeado
            hitTimer: 0,  // Contador de frames para el flash de pantalla
        };
        
        // Referencias a los contenedores
        const scenes = {
            [SCENES.MENU]: document.getElementById(SCENES.MENU),
            [SCENES.CHAR_SELECT]: document.getElementById(SCENES.CHAR_SELECT),
            [SCENES.GAME]: document.getElementById(SCENES.GAME),
            [SCENES.SCORE]: document.getElementById(SCENES.SCORE),
        };

        const appContainer = document.getElementById('app');
        // Canvas y Contexto de Juego
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        let gameLoopId;

        // Variables de juego relativas a la pantalla
        let player = { x: 0, y: 0, width: 0, height: 0, speedFactor: 0.008 }; // Factor de velocidad relativa
        
        // Tamaño visual de los objetos (Duplicado a 0.16)
        const OBJECT_SIZE_RATIO = 0.16; 
        
        // *** Factor de reducción del Hitbox (0.7 = 70% del tamaño visual) ***
        const HITBOX_REDUCTION_FACTOR = 0.7; 

        let playerWidthRatio = 0.15; 
        
        // *** Umbral de puntos para la bomba ***
        const MIN_POINTS_FOR_BOMBS = 500;
        
        // *** Requisito de racha ***
        const COMBO_MAX = 20;
        
        // *** CONSTANTES PARA EL FEEDBACK VISUAL DE DAÑO ***
        const DURATION_MS_HIT_FEEDBACK = 1000; 
        const FLASH_FRAMES = 10; // Duración del flash rojo en frames
        let isFlashing = false; 
        const hitImage = document.getElementById('hit-image');
        // ==================================================================================================
        // RECURSOS (IMÁGENES Y DATOS)
        // ==================================================================================================
        
        const IMAGE_URLS = {
            // Personajes
            MR_BIBERON: 'https://i.postimg.cc/Bnx7nKjH/MR-Biberon.png',
            MAMILA: 'https://i.postimg.cc/59YhMjSm/mamila.png',
            CHUPETE: 'https://i.postimg.cc/zGJ23fKk/Chupete.png', 
            CHUPETON: 'https://i.postimg.cc/B6c18JTW/Chupeton.png', 
            // Botones y HUD
            LIFE_ICON: 'https://i.postimg.cc/7ZqjF9Lj/VIDA.png',
            // Objetos de Juego
            BIBERON: 'https://i.postimg.cc/43cWShgv/Biberon.png',
            BIBERON_PLUS: 'https://i.postimg.cc/Px2Y3tPp/biberon-x2.png',
            ASTEROIDE: 'https://i.postimg.cc/JzX1PPGX/Asteroid.png',
            BOMBA: 'https://i.postimg.cc/66SJgCsd/Bomba.png',
            KABUM: 'https://i.postimg.cc/qBhrw1tP/KABUM.png', 
        };

        const charactersData = [
            { id: 'mr_biberon', name: 'MR BIBERON', image: IMAGE_URLS.MR_BIBERON, ref: '( Cardeologo Lunes y Viernes )' },
            { id: 'mamila', name: 'MAMILA', image: IMAGE_URLS.MAMILA, ref: '( 15 TARDE & ENCALZADO )' },
            { id: 'chupete', name: 'CHUPETE', image: IMAGE_URLS.CHUPETE, ref: '( BRONCEADO PERMANENTE )' },
            { id: 'chupeton', name: 'CHUPETON', image: IMAGE_URLS.CHUPETON, ref: '( LA MANDIBULA MAS LOCA )' }
        ];

        const finalPhrases = [
            "Ya no Tenes mas cardiólogo ni parientes a si que firma",
            "Me estas dejando sin pallet y columnas a si que firma",
            "La semana también tiene LUNES y VIERNES a si que firma",
            "LA siguiente vas a manejar el changuito del super",
            "Estaba Fuerte el sol en urgencia",
            "Podes trabajar y hablar al mismo tiempo"
        ];
        
        // Almacenamiento de las imágenes cargadas
        const images = {};

        // Función para cargar todas las imágenes antes de iniciar
        function loadImages() {
            const promises = Object.keys(IMAGE_URLS).map(key => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = IMAGE_URLS[key];
                    img.onload = () => {
                        images[key] = img;
                        resolve();
                    };
                    img.onerror = () => {
                        console.error(`Error al cargar imagen: ${IMAGE_URLS[key]}`);
                        // Usar placeholder en caso de error para no romper la estética
                        img.src = `https://placehold.co/100x100/F59E0B/white?text=${key}`;
                        images[key] = img;
                        resolve();
                    };
                });
            });
            // Fallback de imagen de feedback en caso de que el URL falle
            hitImage.onerror = () => {
                 console.error("No se pudo cargar la imagen de feedback. Usando un color sólido.");
                 // Usamos un simple color como fallback para el efecto de entrada lateral
                 hitImage.style.backgroundColor = 'rgba(239, 68, 68, 0.8)'; // Rojo peligro
                 hitImage.src = 'https://placehold.co/1x1/FF0000/FFFFFF?text='; 
            };

            return Promise.all(promises);
        }

        // ==================================================================================================
        // NAVEGACIÓN ENTRE CAJAS
        // ==================================================================================================

        function switchScene(sceneName) {
            // Ocultar todas las cajas
            Object.values(scenes).forEach(scene => scene.classList.add('hidden'));

            // Mostrar la caja deseada
            scenes[sceneName].classList.remove('hidden');
            currentScene = sceneName;

            // Lógica específica al cambiar de escena
            if (sceneName === SCENES.CHAR_SELECT) {
                appContainer.classList.remove('repeat-bg', 'caja3-bg');
                appContainer.classList.add('caja2-bg');
                renderCharacterSelection();
            } else if (sceneName === SCENES.GAME) {
                appContainer.classList.remove('repeat-bg', 'caja2-bg');
                appContainer.classList.add('caja3-bg');
                startGame();
            } else {
                appContainer.classList.remove('caja2-bg', 'caja3-bg');
                appContainer.classList.add('repeat-bg');
            }
        }

        // ==================================================================================================
        // CAJA 2: SELECCIÓN DE PERSONAJES
        // ==================================================================================================

        function renderCharacterSelection() {
            const grid = document.getElementById('character-grid');
            grid.innerHTML = '';
            let selectedId = gameState.selectedCharacter ? gameState.selectedCharacter.id : null;
            const selectBtn = document.getElementById('select-character-btn');

            charactersData.forEach(char => {
                const isSelected = char.id === selectedId;
                const charDiv = document.createElement('div');
                charDiv.className = `w-40 md:w-56 p-2 md:p-4 rounded-xl cursor-pointer transition duration-300 transform ${isSelected ? 'scale-110 border-4 border-danger-theme bg-primary-theme/50 shadow-2xl' : 'scale-100 bg-gray-900/50 hover:bg-gray-800/70'}`;
                charDiv.innerHTML = `
                    <div class="flex flex-col items-center">
                        <img src="${char.image}" alt="${char.name}" class="w-28 h-28 md:w-40 md:h-40 object-contain rounded-full mb-2 shadow-xl border-2 ${isSelected ? 'border-white' : 'border-gray-500'}">
                        <h3 class="text-xl font-bold font-display text-text-theme text-center">${char.name}</h3>
                        <p class="text-xs md:text-sm text-gray-300 text-center">${char.ref}</p>
                    </div>
                `;
                charDiv.onclick = () => {
                    gameState.selectedCharacter = char;
                    selectBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    selectBtn.classList.add('hover:scale-105');
                    renderCharacterSelection();
                };
                grid.appendChild(charDiv);
            });

            selectBtn.onclick = () => {
                if (gameState.selectedCharacter) {
                    switchScene(SCENES.GAME);
                }
            };

            if (gameState.selectedCharacter) {
                selectBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                selectBtn.classList.add('hover:scale-105');
            } else {
                selectBtn.classList.add('opacity-50', 'cursor-not-allowed');
                selectBtn.classList.remove('hover:scale-105');
            }
        }
        
        // ==================================================================================================
        // CAJA 3: JUEGO (CANVAS Y LÓGICA FULL SCREEN)
        // ==================================================================================================
        
        let objects = [];
        let objectSpawnTimer = 0;
        
        // *** Tasa de spawn base (más rápido) ***
        const OBJECT_SPAWN_RATE_BASE = 40; 
        const MAX_LIVES = 3;
        
        // Redimensionar Canvas a pantalla completa
        function resizeCanvas() {
            // Ocupa toda el área disponible
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Re-posicionar el jugador y ajustar su tamaño (relativo al ancho)
            player.width = canvas.width * playerWidthRatio; 
            player.height = canvas.width * playerWidthRatio;
            
            // Siempre cerca del fondo
            player.x = (canvas.width / 2) - (player.width / 2);
            player.y = canvas.height - player.height * 1.5; 
        }

        // Clase para los objetos que caen
        class GameObject {
            constructor(type, x, y, speed, direction = 1) {
                this.type = type; 
                this.image = images[type.toUpperCase()];
                
                // Tamaño visual (ancho/alto)
                this.width = canvas.width * OBJECT_SIZE_RATIO;
                this.height = canvas.width * OBJECT_SIZE_RATIO;
                
                // --- AJUSTE DE HITBOX ---
                // Para objetos que dan puntos, el hitbox es 100% para facilitar la recolección
                const currentHitboxFactor = (type === 'biberon' || type === 'biberon_plus') 
                    ? 1.0 
                    : HITBOX_REDUCTION_FACTOR; // 0.7 para Asteroides y Bombas
                
                this.hitboxWidth = this.width * currentHitboxFactor;
                this.hitboxHeight = this.height * currentHitboxFactor;
                // -------------------------

                this.x = x;
                this.y = y;
                this.speed = speed;
                
                // Puntos
                this.points = type === 'biberon' ? 10 : type === 'biberon_plus' ? 20 : 0;
                
                // Daño
                this.damage = type === 'asteroide' ? 1 : type === 'bomba' ? 2 : 0;
                this.hDirection = direction; 
            }

            update() {
                // Movimiento vertical (usando velocidad relativa para fluidez)
                this.y += this.speed * canvas.height * 0.001; 

                // Movimiento horizontal para bombas
                if (this.type === 'bomba') {
                    // La velocidad horizontal también debe ser relativa al ancho
                    this.x += this.hDirection * this.speed * canvas.width * 0.0005; 
                }
            }

            draw() {
                if (this.image) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                }
            }
        }

        // Spawn de objetos
        function spawnObject() {
            // *** Velocidad base del juego sube 25% (3.75) ***
            let baseSpeed = 3.75; 
            
            // *** AUMENTO DE VELOCIDAD DURANTE EL EVENTO ***
            if (gameState.isEventActive) {
                baseSpeed *= 1.8; // Aumenta la velocidad en un 80%
            }
            
            // El multiplicador de velocidad aumenta más despacio para compensar la alta velocidad base
            const scoreMultiplier = Math.floor(gameState.currentScore / 1000); 
            const maxSpeed = baseSpeed + scoreMultiplier * 0.5; // Aumento de velocidad más gradual por score

            const spawnWidth = canvas.width * OBJECT_SIZE_RATIO;
            const spawnHeight = canvas.width * OBJECT_SIZE_RATIO;
            const x = Math.random() * (canvas.width - spawnWidth);
            
            let objectType;
            let hDirection = 0;
            

            // Lógica de spawn
            if (gameState.isEventActive) {
                // MAYOR PROBABILIDAD DE BIBERONES DURANTE EL EVENTO
                objectType = Math.random() < 0.35 ? 'biberon_plus' : 'biberon'; 
            } else {
                // Spawn normal
                const random = Math.random();
                
                // 50% de probabilidad de generar un hazard
                const hazardChance = 0.50; 

                if (random < hazardChance) {
                    // Es un Hazard (Asteroide o Bomba)
                    
                    let isBomba = false;
                    
                    if (gameState.currentScore >= MIN_POINTS_FOR_BOMBS) {
                         // AJUSTE: Si el score >= 500, la bomba tiene 70% de chance de reemplazar al asteroide
                        isBomba = Math.random() < 0.7; 
                    }
                    
                    if (isBomba) {
                        objectType = 'bomba';
                    } else {
                        objectType = 'asteroide';
                    }
                    
                } else {
                    // Es un Collectable
                    objectType = Math.random() < 0.1 ? 'biberon_plus' : 'biberon';
                }
            }
            
            // Si es bomba, configurar la dirección de cruce de pantalla
            if (objectType === 'bomba') {
                hDirection = Math.random() < 0.5 ? 1 : -1; // 1 = se mueve hacia la derecha, -1 = se mueve hacia la izquierda
                
                let startX;
                // Si hDirection es 1 (se mueve hacia la derecha), startX es -spawnWidth (comienza desde la izquierda, fuera de vista)
                // Si hDirection es -1 (se mueve hacia la izquierda), startX es canvas.width (comienza desde la derecha, fuera de vista)
                if (hDirection === 1) {
                    startX = -spawnWidth;
                } else {
                    startX = canvas.width;
                }
                
                // Iniciar la bomba un poco más arriba
                objects.push(new GameObject(objectType, startX, -spawnHeight * 1.5, maxSpeed, hDirection)); 
            } else {
                 objects.push(new GameObject(objectType, x, -spawnHeight, maxSpeed));
            }
           
        }

        /**
         * Función auxiliar para dibujar texto con un contorno grueso (Estilo Cómic/Graffiti).
         * @param {string} text El texto a dibujar.
         * @param {number} x La coordenada X.
         * @param {number} y La coordenada Y.
         * @param {string} fillStyle Color de relleno del texto.
         * @param {string} strokeStyle Color del contorno.
         * @param {number} thickness Grosor del contorno.
         */
        function drawOutlinedText(text, x, y, fillStyle, strokeStyle, thickness = 3) {
            ctx.lineWidth = thickness;
            ctx.strokeStyle = strokeStyle;
            ctx.strokeText(text, x, y);
            ctx.fillStyle = fillStyle;
            ctx.fillText(text, x, y);
            ctx.lineWidth = 1; // Restaurar por si acaso
        }


        // Dibujar el HUD (Vidas a la izquierda, Score a la derecha)
        function drawHUD() {
            const padding = canvas.width * 0.02;
            const fontSize = canvas.width * 0.04;
            const lifeIconSize = canvas.width * 0.05;

            ctx.font = `${fontSize}px Bangers`;
            // IMPORTANTE: Desactivar el blur para un contorno limpio y nítido
            ctx.shadowBlur = 0; 

            // ==========================================================
            // LADO IZQUIERDO: VIDAS
            // ==========================================================
            ctx.textAlign = 'left';
            const lifeIcon = images.LIFE_ICON;
            if (lifeIcon) {
                for (let i = 0; i < MAX_LIVES; i++) {
                    ctx.globalAlpha = i < gameState.lives ? 1.0 : 0.3;
                    ctx.drawImage(lifeIcon, padding + (lifeIconSize * 1.2 * i), padding, lifeIconSize, lifeIconSize);
                }
                ctx.globalAlpha = 1.0;
            }

            // ==========================================================
            // LADO DERECHO: SCORE (Puntuación y Bonus) - ESTILIZADO
            // ==========================================================
            ctx.textAlign = 'right';

            // Puntuación Normal (Texto Blanco, Contorno Naranja, más grande)
            drawOutlinedText(
                `PUNTOS: ${gameState.currentScore}`, 
                canvas.width - padding, 
                padding + lifeIconSize, 
                '#FFFFFF', // Blanco
                '#F59E0B', // primary-theme (Naranja)
                4 // Grosor
            );

            // Puntuación Bonus (Texto Amarillo, Contorno Rojo/Peligro)
            drawOutlinedText(
                `BONUS: ${gameState.bonusScore}`, 
                canvas.width - padding, 
                padding + lifeIconSize + fontSize * 1.2, 
                '#FDE047', // text-theme (Amarillo)
                '#EF4444', // danger-theme (Rojo)
                4
            );
            
            // ==========================================================
            // CENTRO: Indicador de Evento Activo y Combo - ESTILIZADO
            // ==========================================================
            ctx.textAlign = 'center';
            
            if (gameState.isEventActive) {
                // Evento Activo: "NO VALE NADAAA" (Texto Rojo, Contorno Blanco, más grande)
                const eventText = `¡NO VALE NADAAA! ${(gameState.eventTimer / 1000).toFixed(1)}s`;
                const eventFontSize = canvas.width * 0.06;
                ctx.font = `${eventFontSize}px Bangers`;
                drawOutlinedText(
                    eventText, 
                    canvas.width / 2, 
                    padding + lifeIconSize + eventFontSize * 0.5, 
                    '#EF4444', // danger-theme (Rojo)
                    '#FFFFFF', // Blanco 
                    5
                );
                ctx.font = `${fontSize}px Bangers`; // Restaurar font size
            } else {
                // Racha: Verde para progreso, Contorno Naranja/Tema
                const comboText = `Racha: ${gameState.comboCount}/${COMBO_MAX}`;
                drawOutlinedText(
                    comboText, 
                    canvas.width / 2, 
                    padding + lifeIconSize + fontSize * 0.5, 
                    '#10B981', // success-theme (Verde)
                    '#F59E0B', // primary-theme (Naranja)
                    4
                );
            }

            ctx.textAlign = 'left';
            ctx.shadowBlur = 0; // Reset final
        }


        // Manejo de la onomatopeya (texto grande en el centro de la pantalla)
        function showOnomatopeya(text, duration = 1500, style = 'center') {
            const textElement = document.getElementById('onomatopeya-text');
            textElement.textContent = text;
            
            textElement.style.opacity = '1';
            
            // Estética de las onomatopeyas mejorada dramáticamente
            let color, shadow;
            let baseSize = canvas.width * 0.12;

            switch (style) {
                case 'damage': // EPA
                    baseSize = canvas.width * 0.18;
                    color = '#FFFFFF'; 
                    // Sombra con Glow y contorno grueso para el "EPA!!!"
                    shadow = '0 0 15px #FFD700, 0 0 30px #FF4500, 8px 8px 0 #EF4444';
                    break;
                case 'combo': // MAMADERA XN
                    baseSize = canvas.width * 0.10;
                    color = '#34D399'; 
                    // CLAVE: Sombra más pronunciada para MAMADERA
                    shadow = '0 0 10px #065F46, 5px 5px 0 #FFFFFF, 8px 8px 0 #22C55E'; 
                    break;
                case 'center': // NO VALE NADAAA / BONUS
                default:
                    baseSize = canvas.width * 0.12;
                    color = '#FF4500'; 
                    // CLAVE: Sombra más pronunciada para NO VALE NADAAA / BONUS
                    shadow = '0 0 10px #FDE047, 10px 10px 0 #000000, 12px 12px 0 #FF4500'; 
            }

            textElement.style.fontSize = `${baseSize}px`;
            textElement.style.color = color;
            textElement.style.textShadow = shadow;


            setTimeout(() => {
                textElement.style.opacity = '0';
            }, duration);
        }

        /**
         * Función de FEEDBACK: Muestra el feedback visual de daño (flash y texto).
         */
        function showHitFeedback() {
            if (isFlashing) {
                return;
            } 

            isFlashing = true;
            gameState.isHit = true;
            gameState.hitTimer = FLASH_FRAMES; // Inicia el contador de flash del canvas

            // 1. Mostrar la imagen lateral (efecto de transición)
            hitImage.classList.add('hit-visible');
            
            // 2. Mostrar la onomatopeya "¡¡¡EPA!!!" gigante en el centro
            showOnomatopeya("¡¡¡EPA!!!", 900, 'damage'); 

            // 3. Programar el ocultamiento de la imagen lateral (CSS)
            setTimeout(() => {
                hitImage.classList.remove('hit-visible');
                
                // Finalizar el flasheo después de que la transición haya terminado (150ms + buffer)
                setTimeout(() => {
                    isFlashing = false;
                }, 300); 
                
            }, DURATION_MS_HIT_FEEDBACK); // Usando 1000ms
        }

        /**
         * Verifica la colisión AABB entre dos objetos, usando el hitbox reducido del objeto B.
         */
        function checkCollision(objA, objB) {
            // Calcular el hitbox reducido y centrado de objB
            const xOffset = (objB.width - objB.hitboxWidth) / 2;
            const yOffset = (objB.height - objB.hitboxHeight) / 2;

            const objB_hit_x = objB.x + xOffset;
            const objB_hit_y = objB.y + yOffset;
            const objB_hit_w = objB.hitboxWidth;
            const objB_hit_h = objB.hitboxHeight;
            
            // Colisión AABB (jugador vs hitbox reducido del objeto)
            return objA.x < objB_hit_x + objB_hit_w &&
                   objA.x + objA.width > objB_hit_x &&
                   objA.y < objB_hit_y + objB_hit_h &&
                   objA.y + objA.height > objB_hit_y; 
        }


        // Lógica del Evento "NO VALE NADA!!!"
        function startEvent() {
            gameState.isEventActive = true;
            // DURACIÓN DEL EVENTO AJUSTADA A 10 SEGUNDOS
            gameState.eventTimer = 10000; 
            gameState.eventPoints = 0;
            gameState.eventComboMultiplier = 0;
            showOnomatopeya("NO VALE NADAAA!!!", 1500, 'center');
        }

        function endEvent() {
            gameState.isEventActive = false;
            if (gameState.eventComboMultiplier > 0) {
                const bonus = gameState.eventPoints; 
                gameState.bonusScore += bonus;
                showOnomatopeya(`BONUS x${gameState.eventComboMultiplier}: +${bonus}`, 2000, 'center');
            }
            gameState.eventPoints = 0;
            // El contador de racha se reinicia para aumentar la dificultad
            gameState.comboCount = 0; 
        }


        // Pequeño efecto visual de texto flotante (Directo en el Canvas)
        let floatingTexts = [];

        function drawFloatingText(text, x, y, color) {
            // Tamaño de fuente más grande para el texto flotante
            floatingTexts.push({ text, x, y, color, opacity: 1, timer: 60, fontSize: canvas.width * 0.06 }); 
        }

        function updateFloatingTexts() {
            floatingTexts = floatingTexts.filter(t => t.timer > 0);
            
            floatingTexts.forEach(t => {
                t.y -= 1 * (canvas.height * 0.001); // Mover hacia arriba (relativo)
                t.opacity = t.timer / 60; 

                // Usar la función de texto contorneado para los puntos flotantes
                ctx.font = `bold ${t.fontSize}px Bangers`;
                ctx.globalAlpha = t.opacity;
                drawOutlinedText(t.text, t.x, t.y, t.color, '#000000', 3);

                t.timer--;
            });
            ctx.globalAlpha = 1; // Reset alpha
            ctx.shadowBlur = 0; // Reset shadow
        }
        
        // Actualización principal del juego
        function updateGame() {
            // 1. Limpiar Canvas (Para usar el fondo del div padre)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Spawn de Objetos
            let currentSpawnRate = OBJECT_SPAWN_RATE_BASE - Math.min(30, gameState.currentScore / 200); 

            // Tasa de spawn frenética durante el evento
            if (gameState.isEventActive) {
                currentSpawnRate /= 3; 
            }

            if (objectSpawnTimer++ >= currentSpawnRate) {
                spawnObject();
                objectSpawnTimer = 0;
            } 

            // 3. Manejo del Evento
            if (gameState.isEventActive) {
                gameState.eventTimer -= 1000 / 60; 
                if (gameState.eventTimer <= 0) {
                    endEvent();
                }
                if (gameState.eventComboMultiplier > 0) {
                     // Solo mostramos la onomatopeya de combo con menos frecuencia, para que no interfiera con el juego
                     if (objectSpawnTimer % 20 === 0) {
                          showOnomatopeya(`MAMADERA x${gameState.eventComboMultiplier}`, 100, 'combo');
                     }
                }
            }


            // 4. Movimiento y Colisión
            objects = objects.filter(obj => {
                obj.update();
                obj.draw();

                // Colisión con el jugador
                if (checkCollision(player, obj)) {
                    if (obj.damage > 0) { 
                        // El contador de racha se reinicia al recibir daño
                        gameState.comboCount = 0; 

                        gameState.lives -= obj.damage;
                        
                        // *** FEEDBACK DE CHOKE TRIPLE ***
                        showHitFeedback(); 

                        if (gameState.lives <= 0) {
                            const kabum = images.KABUM;
                            // Se verifica si la imagen KABUM se cargó correctamente antes de dibujarla
                            if (kabum && kabum.complete && kabum.naturalHeight !== 0) { 
                                // Dibuja la imagen KABUM sobre el jugador
                                ctx.drawImage(kabum, player.x - player.width/2, player.y - player.height/2, player.width*2, player.height*2);
                            } else {
                                // Fallback visual: Dibujar un círculo rojo si la imagen no está disponible
                                ctx.fillStyle = 'rgba(239, 68, 68, 0.8)'; 
                                ctx.beginPath();
                                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, player.width, 0, Math.PI * 2);
                                ctx.fill();
                                // Mostrar un error de imagen en la consola, aunque no es visible al usuario
                                console.error("La imagen KABUM no se pudo cargar.");
                            }
                            gameOver();
                            return false;
                        }
                    } else if (obj.points > 0) { 
                        // Cálculo de puntos (Doble en evento)
                        let basePoints = obj.points; // 10 o 20
                        let earnedPoints = basePoints;

                        if (gameState.isEventActive) {
                            earnedPoints = basePoints * 2; // Puntos dobles: 20 o 40
                            gameState.eventPoints += earnedPoints;
                            gameState.eventComboMultiplier++; 
                        } else {
                            gameState.currentScore += earnedPoints; // Puntos normales: 10 o 20
                            
                            // CONTADOR DE RACHA SOLO AVANZA CUANDO EL EVENTO NO ESTÁ ACTIVO
                            gameState.comboCount++;
                            
                            // El combo se activa con 20 biberones
                            if (gameState.comboCount >= COMBO_MAX) {
                                gameState.comboCount = 0;
                                startEvent();
                            }
                        }
                        
                        drawFloatingText(`+${earnedPoints}`, obj.x + obj.width / 2, obj.y, 
                            obj.type === 'biberon_plus' ? '#F59E0B' : '#34D399');
                    }
                    return false;
                }

                // Objetos fuera de pantalla. 
                if (obj.type === 'bomba') {
                    // Mantener en pantalla si aún está visible horizontalmente Y no ha caído muy abajo
                    return (obj.x < canvas.width && obj.x > -obj.width) && obj.y < canvas.height * 1.5; 
                } else {
                    // Otros objetos desaparecen si caen fuera de la vista inferior
                    return obj.y < canvas.height;
                }
            });

            // 5. Dibujar Jugador
            const charImage = gameState.selectedCharacter ? images[gameState.selectedCharacter.id.toUpperCase()] : images.MR_BIBERON;
            if (charImage) {
                // Si el jugador está siendo golpeado, hacerlo parpadear (cambiar su opacidad)
                 ctx.globalAlpha = gameState.isHit && gameState.hitTimer % 2 === 0 ? 0.4 : 1.0; 
                ctx.drawImage(charImage, player.x, player.y, player.width, player.height);
                ctx.globalAlpha = 1.0; // Reset
            }

            // 6. Dibujar HUD (Integrado)
            drawHUD();
            
            // 7. Actualizar textos flotantes (Integrado)
            updateFloatingTexts();
            
            // 8. NUEVO: Dibujar Flash de Pantalla (Debe ser lo ÚLTIMO en el canvas)
            if (gameState.isHit && gameState.hitTimer > 0) {
                // Red screen flash over everything
                // Opacidad que se desvanece de 0.4 a 0.0
                ctx.globalAlpha = gameState.hitTimer / (FLASH_FRAMES * 2.5); 
                ctx.fillStyle = 'red';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
                
                gameState.hitTimer--;
                if (gameState.hitTimer <= 0) {
                    gameState.isHit = false;
                    // Asegurarse de que la imagen lateral también se oculte, aunque el CSS lo maneja
                    hitImage.classList.remove('hit-visible'); 
                    isFlashing = false;
                }
            }


            // 9. Próximo frame
            if (gameState.lives > 0) {
                gameLoopId = requestAnimationFrame(updateGame);
            }
        }

        // Lógica de inicio y fin del juego
        function startGame() {
            gameState.currentScore = 0;
            gameState.bonusScore = 0;
            gameState.lives = MAX_LIVES;
            gameState.comboCount = 0;
            gameState.isEventActive = false;
            gameState.isHit = false;
            gameState.hitTimer = 0;
            objects = [];
            
            resizeCanvas(); 
            window.addEventListener('resize', resizeCanvas);

            setupPlayerControls();

            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(updateGame);
        }

        function gameOver() {
            cancelAnimationFrame(gameLoopId);
            window.removeEventListener('resize', resizeCanvas);
            
            setTimeout(() => {
                 switchScene(SCENES.SCORE);
                 setupScoreScreen();
            }, 1500);
        }

        // ==================================================================================================
        // CONTROL DEL JUGADOR (TÁCTIL Y TECLADO)
        // ==================================================================================================
        
        let startX = 0;

        function setupPlayerControls() {
            // **Control Táctil**
            canvas.addEventListener('touchstart', (e) => {
                if (gameState.lives <= 0) return;
                startX = e.touches[0].clientX;
            }, { passive: false }); 

            canvas.addEventListener('touchmove', (e) => {
                if (gameState.lives <= 0) return;
                
                const currentX = e.touches[0].clientX;
                const deltaX = currentX - startX;
                
                // Mueve al jugador usando un factor de la velocidad y el ancho del canvas
                let newX = player.x + deltaX * 1.5; 
                
                // Limitar el movimiento
                if (newX < 0) newX = 0;
                if (newX > canvas.width - player.width) newX = canvas.width - player.width;

                player.x = newX;
                startX = currentX; 

                e.preventDefault(); 
            }, { passive: false });

            // **Control de Teclado (para desktop/testing)**
            document.onkeydown = (e) => {
                if (gameState.lives <= 0) return;
                // Velocidad relativa al ancho del canvas
                const moveAmount = player.speedFactor * canvas.width * 8; 
                if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
                    player.x = Math.max(0, player.x - moveAmount);
                }
                if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
                    player.x = Math.min(canvas.width - player.width, player.x + moveAmount);
                }
            };
        }

        // ==================================================================================================
        // CAJA 4: PANTALLA DE PUNTUACIÓN (ACTUALIZADA)
        // ==================================================================================================

        function setupScoreScreen() {
            const totalScore = gameState.currentScore + gameState.bonusScore;
            
            document.getElementById('score-normal-final').textContent = gameState.currentScore;
            document.getElementById('score-bonus-final').textContent = gameState.bonusScore;
            document.getElementById('score-total-final').textContent = totalScore;
            
            const randomIndex = Math.floor(Math.random() * finalPhrases.length);
            document.getElementById('final-phrase').textContent = finalPhrases[randomIndex];

            // Re-aplicar el estilo 'display' para forzar la fuente Bangers en el botón
            document.getElementById('firma-btn').style.fontFamily = 'Bangers, cursive';

            document.getElementById('firma-btn').onclick = () => {
                document.getElementById('firma-input').value = ''; 
                switchScene(SCENES.MENU);
            };
        }


        // ==================================================================================================
        // INICIO DE LA APLICACIÓN
        // ==================================================================================================
        
        window.onload = function() {
            loadImages().then(() => {
                document.getElementById('start-game-btn').onclick = () => {
                    if (!gameState.selectedCharacter) {
                         gameState.selectedCharacter = charactersData[0];
                    }
                    switchScene(SCENES.CHAR_SELECT);
                };
                
                switchScene(SCENES.MENU);
            });
        };
    </script>
</body>
</html>
